// Forward pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}
	
#if UNITY_VFX_SG
	${VFXSGParticleAttributesStruct_Forward}
#endif
	
	struct ps_input
	{
		float4 pos : SV_POSITION;
		float3 offsets : TEXCOORD0;
#if UNITY_VFX_SG        
        #if VFX_SG_PIXEL_REQUIRE_COLOR_FORWARD
            nointerpolation float4 color : COLOR0;
        #endif
#else
		#if VFX_NEEDS_COLOR_INTERPOLATOR
		nointerpolation float4 color : COLOR0;
		#endif
#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST
		// x: inverse soft particles fade distance
		// y: alpha threshold
		nointerpolation float2 builtInInterpolants : TEXCOORD1;
		#endif
		nointerpolation uint faceID : TEXCOORD2;
		#if VFX_NEEDS_POSWS_INTERPOLATOR
		float3 posWS : TEXCOORD3;
		#endif
#if UNITY_VFX_SG
        ParticleAttributes particle;
#endif

		#if WRITE_MOTION_VECTOR_IN_FORWARD
		float4 cPosPrevious : TEXCOORD4;
		float4 cPosNonJiterred : TEXCOORD5;
		#endif
		
		UNITY_VERTEX_OUTPUT_STEREO
	};
	
	struct ps_output
	{
		float4 color : SV_Target0;
#if WRITE_MOTION_VECTOR_IN_FORWARD
		float4 outMotionVector : SV_Target1;
#endif
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_OFFSETS offsets
#define VFX_VARYING_FACEID faceID
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if WRITE_MOTION_VECTOR_IN_FORWARD
#define VFX_VARYING_VELOCITY_CPOS cPosNonJiterred
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS cPosPrevious
#endif
								
	${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}	
    
   
#if UNITY_VFX_SG
    ${GetSurfaceFunctionDefinition_Forward}
    
    FragInputs GetFormattedInputs(ps_inputs i)
    {
        FragInputs formattedInputs = (FragInputs)0;
        formattedInputs.positionRWS = i.pos;
#if VFX_SG_PIXEL_REQUIRE_TANGENT_FORWARD || VFX_SG_PIXEL_REQUIRE_NORMAL_FORWARD
        formattedInputs.tangentToWorld = BuildTangentToWorld(VFXCubeGetLocalTangent(i), VFXCubeGetLocalNormal(i));

        
#if VFX_SG_PIXEL_REQUIRE_TEXCOORD0_FORWARD
        formattedInputs.texCoord0 = VFXCubeGetUV(i);
#endif 
    // mesh is procedural so texCoord1-3 are zero filled.
#if VFX_SG_PIXEL_REQUIRE_COLOR
        formattedInputs.color = i.color;
#endif
        return formattedInputs;
    }
#endif //UNITY_VFX_SG
		
	#pragma fragment frag
	ps_output frag(ps_input i)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		ps_output o = (ps_output)0;
		VFXTransformPSInputs(i);
#if UNITY_VFX_SG
        FragInputs formattedInputs = GetFormattedInputs(i);
		
        i.particle.color.a *= VFXGetSoftParticleFade(i);
        o.color = GetSurfaceFunction(formattedInputs,i.particle);
#else
		o.color = VFXGetFragmentColor(i);
		o.color *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFXCubeGetUV(i));
#endif
		o.color = VFXApplyFog(o.color,i);
		VFXClipFragmentColor(o.color.a,i);

#if WRITE_MOTION_VECTOR_IN_FORWARD
		${VFXComputeOutputMotionVector}
		o.outMotionVector = encodedMotionVector;
#endif
		return o;
	}
	ENDHLSL
}
